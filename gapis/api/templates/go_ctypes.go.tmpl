{{/*
 * Copyright (C) 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */}}

{{/* ---- Includes ---- */}}
{{Include "go_common.tmpl"}}
{{Include "cpp_common.tmpl"}}

{{$filename := "ctypes.go" }}
{{$ | Macro "Types" | Reflow 4 | Write $filename}}

{{define "Types"}}
  {{AssertType $ "API"}}
  {{template "Go.GeneratedHeader" (Global "OutputDir")}}
¶  
// #include "gapis/api/vulkan/ctypes.h"
import "C"
import "unsafe"
import "github.com/google/gapid/core/memory/arena"
import "github.com/google/gapid/gapis/api"
¶
  {{range $e := $.Enums}}
    {{Template "DeclareEnum" $e}}
¶
  {{end}}
¶
  {{range $m := $.Maps}}
    {{Template "DeclareMap" $m}}
¶
  {{end}}
  {{range $c := $.Classes}}
    {{Template "DeclareClass" $c}}
¶
  {{end}}
  {{range $c := AllCommands $}}
    {{range $p := $c.CallParameters}}
      {{Template "DeclareConstructorType" $p}}
¶
    {{end}}
  {{end}}
¶
  {{range $c := AllCommands $}}
    {{Template "DeclareCommand" $c}}
  {{end}}
¶
{{end}}

{{/*
-------------------------------------------------------------------------------
  Emits the declaration of the map's key and value types (if it is not already
  declared) followed by the map's declaration as a gapil::Map.
-------------------------------------------------------------------------------
*/}}
{{define "DeclareMap"}}
  {{$name   := Macro "C++.TypeName" $}}
  {{$key    := Macro "Go.Type" $.KeyType}}
  {{$value    := Macro "Go.Type" $.ValueType}}
  {{Template "DeclareType" $.KeyType}}
  {{Template "DeclareType" $.ValueType}}

  type {{$name}} struct {
    c C.{{$name}}
  }

  type {{$name}}_Iterator struct {
    offset uint32
    c C.{{$name}}
  }

  func (f {{$name}}) Get(k {{$key}}) {{Template "ConstructorType" $.ValueType}} {
    {{if IsBool ($.ValueType | Underlying)}}
      return false
    {{else if IsNumericType ($.ValueType | Underlying)}}
      return {{Template "ConstructorType" $.ValueType}}(0)
    {{else if IsEnum $.ValueType}}
      return {{Template "ConstructorType" $.ValueType}}(0)
    {{else if IsString $.ValueType}}
      return {{Template "ConstructorType" $.ValueType}}("")
    {{else}}
      // TODO: Fill this in correctly
      return {{Template "ConstructorType" $.ValueType}}{}
    {{end}}
    
  }
  func (f {{$name}}) First() {{$name}}_Iterator { 
    // TODO: Fill this in correctly
    return {{$name}}_Iterator{}
  }

{{end}}

{{/*
-------------------------------------------------------------------------------
  Emits the declaration of the C class
-------------------------------------------------------------------------------
*/}}
{{define "DeclareClass"}}
  {{$name   := Macro "C++.TypeName" $}}

  {{range $f := $.Fields}}
    {{Template "DeclareType" $f}}
  {{end}}

  type __{{$name}} struct {
    c *C.{{$name}}
  }
  {{$struct   := Macro "C++.TypeName" $}}
  {{range $f := $.Fields}}
    {{Template "DeclareGetterSetter" "Struct" (printf "__%v" $struct) "Name" $f.Name "Type" $f.Type}}
  {{end}}
{{end}}

{{define "DeclareType"}}
  {{if not (IsType $)}}{{Template "DeclareType" (TypeOf $)}}
  {{else if not (IsBuiltin $)}}
    {{$key  := printf "ApiType%vDeclared" $.Name}}
    {{if not (Global $key)}}
      {{Global $key "true"}}
      {{if IsReference   $}}{{Template "DeclareRef" $}}
      {{else if IsSlice   $}}{{Template "DeclareSlice" $}}
      {{else if IsPointer $}}{{Template "DeclarePointer" $}}
      {{else if IsPseudonym $}} 
        {{Template "DeclareType" $.To}}
        type __{{$.Name}} {{Template "ConstructorType" $.To}}
      {{else}}
      {{end}}
      ¶
    {{end}}
  {{end}}
{{end}}

{{define "DeclareRef"}}
    {{$name := Macro "ConstructorType" $.To}}
    {{$cname := Macro "CGoType" $.To}}
    type {{$name}}_ref struct {
      c {{$cname}}_ref
    }

    func (c {{$name}}_ref) Get() {{$name}} {
      return {{$name}}{&c.c.val}
    }
{{end}}

{{define "DeclareEnum"}}
    {{$name := Macro "ConstructorType" $}}
    type __{{$.Name}} {{Template "Go.Type" $.NumberType}}
    »{{Template "DeclareEnumEntries" $}}«
{{end}}

{{/*
-------------------------------------------------------------------------------
  Emits enum entry declarations as a number of uint32_t constants.
-------------------------------------------------------------------------------
*/}}
{{define "DeclareEnumEntries"}}
  {{AssertType $ "Enum"}}

  {{range $entry := $.Entries}}
    const {{$entry.Name}} = __{{$.Name}}({{$entry.Value}})
  {{end}}
{{end}}


{{define "DeclareSlice"}}
    {{Template "DeclareType" $}}
    {{$name := Macro "C++.TypeName" $.To}}
    {{$cname := Macro "CGoType" $}}
    {{$cbaseName := Macro "CGoType" $.To}}
    type {{$name}}_slice struct {
      c *{{$cname}}
    }

    func (c {{$name}}_slice) Get(i int32) {{Template "ConstructorType" $.To}} {
      offset := uintptr(unsafe.Sizeof(*c.c.base))*uintptr(i)
      base := (*{{$cbaseName}})(unsafe.Pointer(uintptr(unsafe.Pointer(c.c.base)) + offset))
      return {{Template "ToGoCast" "Type" $.To "Name" "*base"}}
    }
    func (c {{$name}}_slice) Set(i int32, val {{Template "ConstructorType" $.To}})  {
      offset := uintptr(unsafe.Sizeof(*c.c.base))*uintptr(i)
      base := (*{{$cbaseName}})(unsafe.Pointer(uintptr(unsafe.Pointer(c.c.base)) + offset))
      *base = {{Template "ToCCast" "Type" $.To "Name" "val"}}
    }
{{end}}

{{define "ConstName"}}
  {{if $.Const}}_const{{end}}
{{end}}

{{define "GoDerefCPointer"}}
  {{if IsClass ($.Type | Underlying) }}
    {{Template "ConstructorType" $.Type}}{ {{$.Name}}.c }
  {{else if IsPointer ($.Type | Underlying)}}
    {{Template "ConstructorType" $.Type}}{({{Template "CGoType" $.Type}})(*{{$.Name}}.c)}
  {{else}}
    {{Template "ConstructorType" $.Type}}(*{{$.Name}}.c)
  {{end}}
{{end}}

{{define "ToGoCast"}}
  {{AssertType $.Type "Type"}}
  {{if IsClass ($.Type | Underlying)}}
    {{Template "ConstructorType" $.Type}}{ &{{$.Name}} }
  {{else if IsSlice ($.Type | Underlying)}}
    {{Template "ConstructorType" $.Type}}{ &{{$.Name}} }
  {{else if IsMap ($.Type | Underlying)}}
    {{Template "ConstructorType" $.Type}}{ {{$.Name}} }
  {{else if IsString ($.Type | Underlying)}}
    C.GoStringN((*C.char)(unsafe.Pointer(&{{$.Name}}.data[0])), (C.int)({{$.Name}}.length))
  {{else if IsPointer ($.Type | Underlying)}}
    {{Template "ConstructorType" $.Type}}{ {{$.Name}} }
  {{else}}
    {{Template "ConstructorType" $.Type}}({{$.Name}})
  {{end}}
{{end}}

{{define "ToCCast"}}
  {{AssertType $.Type "Type"}}
  {{if IsClass ($.Type | Underlying)}}
    *{{$.Name}}.c
  {{else if IsSlice ($.Type | Underlying)}}
    *{{$.Name}}.c
  {{else if IsMap ($.Type | Underlying)}}
    ({{Template "CGoType" $.Type}})({{$.Name}}.c)
  {{else if IsPointer ($.Type | Underlying)}}
    ({{Template "CGoType" $.Type}})({{$.Name}}.c)
  {{else}}
    {{Template "CGoType" $.Type}}({{$.Name}})
  {{end}}
{{end}}


{{define "AssignRef"}}
  {{AssertType $.Type "Type"}}
  {{if IsClass ($.Type | Underlying)}}
    *{{$.Name}}.c
  {{else if IsSlice ($.Type | Underlying)}}
    *{{$.Name}}.c
  {{else if IsMap ($.Type | Underlying)}}
    ({{Template "CGoType" $.Type}})({{$.Name}}.c)
  {{else if IsPointer ($.Type | Underlying)}}
    ({{Template "CGoType" $.Type}})({{$.Name}}.c)
  {{else}}
    {{Template "CGoType" $.Type}}({{$.Name}})
  {{end}}
{{end}}


{{define "DeclarePointer"}}
    {{Template "DeclareType" $.To}}
    
    {{$name := Macro "C++.TypeName" $.To}}
    {{$const := Macro "ConstName" $}}
    type {{$name}}{{$const}}_ptr struct {
      c *{{Template "CGoType" $.To}}
    }

    {{if not (IsVoid $.To)}}
      func (c {{$name}}{{$const}}_ptr) Get() {{Template "ConstructorType" $.To}} {
        return {{Template "GoDerefCPointer" "Type" $.To "Name" "c"}}
      }
      {{if not ($.Const)}}
        func (c {{$name}}{{$const}}_ptr) Set(val {{Template "ConstructorType" $.To}})  {
          *c.c = {{Template "AssignRef" "Type" $.To "Name" "val"}}
        }
      {{end}}

      func (c {{$name}}{{$const}}_ptr) Offset(idx int) {{$name}}{{$const}}_ptr {
        ptr := unsafe.Pointer(uintptr(unsafe.Pointer(c.c)) + uintptr(unsafe.Sizeof(*c.c))*uintptr(idx))
        return {{$name}}{{$const}}_ptr{ (*{{Template "CGoType" $.To}})(ptr) }
      }
    {{end}}
{{end}}

{{/*
-------------------------------------------------------------------------------
  Emits the declaration of the C class
-------------------------------------------------------------------------------
*/}}
{{define "DeclareGetterSetter"}}
  {{$field_title := Title $.Name}}
  

  {{if IsMap $.Type}}
    {{$name   := Macro "C++.TypeName" $.Type}}
    func (c {{$.Struct}}) {{$field_title}}() {{$name}} {
      return {{Template "ConstructorType" $.Type}}{c.c.{{$.Name}}}
    }
  {{else if IsReference $.Type}}
    func (c {{$.Struct}}) {{$field_title}}() {{Template "ConstructorType" $.Type}} {
      return {{Template "ConstructorType" $.Type}}{c.c.{{$.Name}}}
    }
  {{else}}
    func (c {{$.Struct}}) {{$field_title}}() {{Template "ConstructorType" $.Type}} {
      {{if IsStaticArray $.Type}}
        var ret_v {{Template "ConstructorType" $.Type}}
        for i := 0; i < {{$.Type.Size}}; i++ {
          ret_v[i] = {{Template "ToGoCast" "Type" $.Type.ValueType "Name" (printf "c.c.%s[i]" $.Name)}}
        }
        return ret_v
      {{else}}
        return {{Template "ToGoCast" "Type" $.Type "Name" (printf "c.c.%s" $.Name)}}
      {{end}}
    }
    {{if not (IsString $.Type)}}
      func (c {{$.Struct}}) Set{{$field_title}}(v {{Template "ConstructorType" $.Type}}) {
        {{if IsStaticArray $.Type}}
          for i, v := range v {
            c.c.{{$.Name}}[i] = {{Template "ToCCast" "Type" $.Type.ValueType "Name" "v"}}
          }
        {{else}}
          c.c.{{$.Name}} =  {{Template "ToCCast" "Type" $.Type "Name" "v"}}
        {{end}}
      }
    {{end}}
  {{end}}
{{end}}

{{define "CGoType"}}
    {{if not (IsType $)}}{{Template "CGoType" (TypeOf $)}}
      {{else if IsVoid        $}}C.void_t
      {{else if IsBool        $}}C.bool
      {{else if IsInt         $}}C.int
      {{else if IsUint        $}}C.uint
      {{else if IsSize        $}}C.size_t
      {{else if IsChar        $}}C.char
      {{else if IsU8          $}}C.uint8_t
      {{else if IsS8          $}}C.int8_t
      {{else if IsU16         $}}C.uint16_t
      {{else if IsS16         $}}C.int16_t
      {{else if IsF32         $}}C.float
      {{else if IsU32         $}}C.uint32_t
      {{else if IsS32         $}}C.int32_t
      {{else if IsF64         $}}C.double
      {{else if IsU64         $}}C.uint64_t
      {{else if IsS64         $}}C.int64_t
      {{else if IsString      $}}C.string
      {{else if IsPseudonym   $}}C.{{$.Name}}
      {{else if IsSlice       $}}C.{{Macro "C++.TypeName" $.To}}_slice
      {{else if IsEnum        $}}C.{{$.Name}}
      {{else if IsStaticArray $}}{{Template "CGoType" $.ValueType}}[{{$.Size}}]
      {{else if IsPointer     $}}*{{Template "CGoType" $.To}}
      {{else if IsClass       $}}C.{{Template "C++.TypeName" $}}
      {{else}}{{Error "DeclareConstructorType does not support type '%T'" $}}
      {{end}}
{{end}}


{{define "DeclareConstructorType"}}
  {{if not (IsType $)}}{{Template "DeclareConstructorType" (TypeOf $)}}
  {{else if IsVoid        $}}
  {{else if IsBool        $}}
  {{else if IsInt         $}}
  {{else if IsUint        $}}
  {{else if IsSize        $}}
  {{else if IsChar        $}}
  {{else if IsU8          $}}
  {{else if IsS8          $}}
  {{else if IsU16         $}}
  {{else if IsS16         $}}
  {{else if IsF32         $}}
  {{else if IsU32         $}}
  {{else if IsS32         $}}
  {{else if IsF64         $}}
  {{else if IsU64         $}}
  {{else if IsS64         $}}
  {{else if IsPseudonym   $}}
  {{else if IsBuiltin     $}}
  {{else if IsEnum        $}}{{Template "DeclareConstructorType" $.NumberType}}
  {{else if IsStaticArray $}}{{Template "DeclareConstructorType" $.ValueType}}
  {{else if IsPointer     $}}{{Template "DeclareConstructorType" $.To}}
  {{else if IsClass       $}}{{Template "DeclareClassConstructor" $}}
  {{else}}{{Error "DeclareConstructorType does not support type '%T'" $}}
  {{end}}
{{end}}

{{define "ConstructorType"}}
  {{if not (IsType $)}}{{Template "ConstructorType" (TypeOf $)}}
  {{else if IsBool        $}}bool
  {{else if IsInt         $}}int
  {{else if IsUint        $}}uint
  {{else if IsSize        $}}uint64
  {{else if IsChar        $}}uint8
  {{else if IsU8          $}}uint8
  {{else if IsS8          $}}int8
  {{else if IsU16         $}}uint16
  {{else if IsS16         $}}int16
  {{else if IsF32         $}}float32
  {{else if IsU32         $}}uint32
  {{else if IsS32         $}}int32
  {{else if IsF64         $}}float64
  {{else if IsU64         $}}uint64
  {{else if IsS64         $}}int64
  {{else if IsBuiltin     $}}{{Template "Go.Type" $}}
  {{else if IsSlice       $}}{{Template "C++.TypeName" $.To}}_slice
  {{else if IsPseudonym   $}}__{{Template "C++.TypeName" $}}
  {{else if IsEnum        $}}__{{$.Name}}
  {{else if IsStaticArray $}}[{{$.Size}}]{{Template "ConstructorType" $.ValueType}}
  {{else if IsPointer     $}}{{Template "C++.TypeName" $.To}}{{Template "ConstName" $}}_ptr
  {{else if IsReference   $}}__{{Template "C++.TypeName" $.To}}_ref
  {{else if IsClass       $}}__{{Template "C++.TypeName" $}}
  {{else if IsMap         $}}{{Template "C++.TypeName" $}}
  {{else}}{{Error "ConstructorType does not support type '%T'" $}}
  {{end}}
{{end}}

{{define "DeclareClassConstructor"}}
  {{AssertType $ "Class"}}
  {{$struct   := Macro "ConstructorType" $}}
  {{$c_struct   := Macro "CGoType" $}}
  {{$key  := printf "ApiType%vConstructorDeclared" $.Name}}
  {{if not (Global $key)}}
    {{Global $key "true"}}
    {{range $f := $.Fields}}
      {{Template "DeclareConstructorType" (TypeOf $f)}}
    {{end}}
    func New{{$struct}}(alloc *arena.Arena) {{$struct}} {
      mem := alloc.Allocate((int)(unsafe.Sizeof({{$c_struct}}{})), (int)(unsafe.Alignof({{$c_struct}}{})))
      return {{$struct}}{(*{{$c_struct}})(mem)}
    }
  {{end}}
{{end}}


{{define "DeclareCommand"}}
  {{$name := Macro "CmdName" $}}
  {{range $p := $.CallParameters}}
    {{Template "DeclareType" $p.Type}}
  {{end}}

  type __{{$name}} struct {
    c *C.{{$name}}
    Extras []api.CmdExtra
  }

  {{range $p := $.CallParameters}}
    {{Template "DeclareGetterSetter" "Struct" (printf "__%v" $name) "Name" $p.Name "Type" $p.Type}}
¶
  {{end}}
{{end}}