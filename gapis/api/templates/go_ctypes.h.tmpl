{{/*
 * Copyright (C) 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */}}

{{/* ---- Includes ---- */}}
{{Include "cpp_common.tmpl"}}

{{/* ---- Overrides ---- */}}
{{Global "C++.StringTypeOverride" "gapil_string"}}

{{$filename := "ctypes.h" }}
{{$ | Macro "Types" | Reflow 4 | Write $filename}}

{{define "Types"}}
  {{AssertType $ "API"}}
  {{Template "C++.Copyright"}}
  {{$guard := print "GAPIS_" (Upper (Global "API")) "_CTYPES_H"}}
¶
  #ifndef {{$guard}}
  #define {{$guard}}
¶
  #include "gapil/runtime/cc/runtime.h"
  #include <stdint.h>
  #include <stdbool.h>
  typedef uint8_t void_t;
¶
  {{range $c := $.Classes}}
    {{Template "ForwardDeclareType" $c}}
  {{end}}
¶
  {{range $e := $.Enums}}
    {{Template "DeclareType" $e}}
  {{end}}
¶
  {{range $p := $.Pseudonyms}}
    {{Template "DeclareType" $p}}
  {{end}}
¶
  {{range $m := $.Maps}}
    {{Template "DeclareType" $m}}
  {{end}}
¶
  {{range $c := $.Classes}}
    {{Template "DeclareType" $c}}
  {{end}}
¶
  {{range $c := AllCommands $}}
    {{Template "DeclareCommand" $c}}
  {{end}}
¶
  #endif // {{$guard}}
{{end}}

{{/*
-------------------------------------------------------------------------------
  Emits C type forward declaration for specified AST type
-------------------------------------------------------------------------------
*/}}
{{define "ForwardDeclareType"}}
  {{if not (IsBuiltin $)}}
    {{if IsClass $}}struct __{{Template "C.Type" $}};
      typedef struct __{{Template "C.Type" $}} {{Template "C.Type" $}};
    {{end}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C type for the specified AST type.
-------------------------------------------------------------------------------
*/}}
{{define "C.Type"}}
  {{if not (IsType $)}}{{Template "C.Type" (TypeOf $)}}
  {{else if IsVoid        $}}void_t
  {{else if IsBool        $}}bool
  {{else if IsInt         $}}int
  {{else if IsUint        $}}unsigned int
  {{else if IsSize        $}}size_t
  {{else if IsChar        $}}char
  {{else if IsU8          $}}uint8_t
  {{else if IsS8          $}}int8_t
  {{else if IsU16         $}}uint16_t
  {{else if IsS16         $}}int16_t
  {{else if IsF32         $}}float
  {{else if IsU32         $}}uint32_t
  {{else if IsS32         $}}int32_t
  {{else if IsF64         $}}double
  {{else if IsU64         $}}uint64_t
  {{else if IsS64         $}}int64_t
  {{else if IsEnum        $}}{{$.Name}}
  {{else if IsReference   $}}{{Template "C.Type" $.To}}_ref
  {{else if IsString      $}}string*
  {{else if IsStaticArray $}}{{Template "C.Type" $.ValueType}}
  {{else if IsSlice       $}}{{Template "C++.TypeName" $.To}}_slice
  {{else if IsPointer     $}}{{Template "C.Type" $.To}}{{if $.Const}} const{{end}}*
  {{else if IsMap         $}}{{Template "C++.TypeName" $}}
  {{else if IsPseudonym   $}}{{Template "C++.TypeName" $}}
  {{else}}{{Template "C++.TypeName" $}}
  {{end}}
{{end}}

{{/*
-------------------------------------------------------------------------------
  Emits the C type declaration specified AST type if it hasn't already been
  declared.
-------------------------------------------------------------------------------
*/}}
{{define "DeclareType"}}
  {{if not (IsBuiltin $)}}
    {{$key  := printf "ApiType%vDeclared" $.Name}}
    {{if not (Global $key)}}
      {{Global $key "true"}}
      {{     if IsClass       $}}{{Template "DeclareClass"     $}}
      {{else if IsEnum        $}}{{Template "DeclareEnum"      $}}
      {{else if IsMap         $}}{{Template "DeclareMap"       $}}
      {{else if IsPseudonym   $}}{{Template "DeclarePseudonym" $}}
      {{else if IsPointer     $}}{{Template "DeclareType"      $.To}}
      {{else if IsReference   $}}{{Template "DeclareRef"       $}}
      {{else if IsStaticArray $}}{{Template "DeclareType"      $.ValueType}}
      {{else if IsSlice       $}}{{Template "DeclareSlice"     $}}
      {{else}}{{Error "DeclareType does not support type '%T'" $}}
      {{end}}
    {{end}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the declarations for all non-declared field types of the class followed
  by the class declaration.
-------------------------------------------------------------------------------
*/}}
{{define "DeclareClass"}}
  {{AssertType $ "Class"}}
  {{range $f := $.Fields}}
    {{Template "DeclareType" (TypeOf $f)}}
  {{end}}

  {{$name := Macro "C++.TypeName" $}}
  typedef struct __{{$name}} {
    {{range $f := $.Fields}}
      {{Template "C.Type" $f}} {{$f.Name}}{{if IsStaticArray $f.Type}}[{{$f.Type.Size}}]{{end}};
    {{end}}
    {{if not (len $.Fields)}}
      uint8_t __dummy; // At least one field so Cgo sees the type.
    {{end}}
  } {{$name}};¶
{{end}}

{{/*
-------------------------------------------------------------------------------
  Emits the declaration of the pseudonym's target type (if it is not already
  declared) followed by the pseudonym's typedef declaration.
-------------------------------------------------------------------------------
*/}}
{{define "DeclarePseudonym"}}
  {{AssertType $ "Pseudonym"}}

  {{Template "DeclareType" $.To}}

  typedef {{Template "C.Type" $.To}} {{Template "C.Type" $}};
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the declaration of the map's key and value types (if it is not already
  declared) followed by the map's declaration as a gapil::Map.
-------------------------------------------------------------------------------
*/}}
{{define "DeclareMap"}}
  {{AssertType $ "Map"}}

  {{Template "DeclareType" $.KeyType}}
  {{Template "DeclareType" $.ValueType}}

  typedef struct __{{Template "C++.TypeName" $}}_element {
    uint64_t used;
    {{Template "C.Type" $.KeyType}} first;
    {{Template "C.Type" $.ValueType}} second;
  } {{Template "C++.TypeName" $}}_element;

  typedef struct __{{Template "C++.TypeName" $}}_map {
    uint32_t ref_count;
    struct arena* arena;
    uint64_t count;
    uint64_t capacity;
    {{Template "C.Type" $}}_element* elements;
  } {{Template "C++.TypeName" $}}_map;
  typedef struct {{Template "C.Type" $}}_map* {{Template "C++.TypeName" $}};
¶
{{end}}

{{/*
-------------------------------------------------------------------------------
  Emits the declaration of the ref
-------------------------------------------------------------------------------
*/}}
{{define "DeclareRef"}}
  {{AssertType $ "Reference"}}

  {{Template "DeclareType" $.To}}

  typedef struct __{{Template "C++.TypeName" $.To}}_ref_data {
    uint32_t ref_count;
    struct arena* arena;
    {{Template "C.Type" $.To}} val;
  } {{Template "C++.TypeName" $.To}}_ref_data;

  typedef {{Template "C.Type" $.To}}_ref_data* {{Template "C++.TypeName" $.To}}_ref;
¶
{{end}}

{{define "DeclareSlice"}}
  {{AssertType $ "Slice"}}
  {{if not (IsBuiltin $.To)}}
    {{Error "DeclareSlice can only handle builtin types. Got: '%T'" $.To}}
  {{end}}

  typedef struct __{{Template "C++.TypeName" $.To}}_slice {
    pool* pool;
    void* root;
    {{Template "C.Type" $.To}}* base;
    uint64_t size;
  } {{Template "C++.TypeName" $.To}}_slice;
¶
{{end}}

{{/*
-------------------------------------------------------------------------------
  Emits the declaration of the map's key and value types (if it is not already
  declared) followed by the map's declaration as a gapil::Map.
-------------------------------------------------------------------------------
*/}}
{{define "DeclareEnum"}}
  typedef {{Template "C++.EnumType" $}} {{$.Name}};
{{end}}

{{define "DeclareCommand"}}
  {{$name := Macro "CmdName" $}}
  typedef struct __{{$name}} {
    uint64_t thread_id;
    {{range $p := $.CallParameters}}
      {{Template "C.Type" $p}} {{$p.Name}}{{if IsStaticArray $p.Type}}[{{$p.Type.Size}}]{{end}};
    {{end}}
    {{if not (IsVoid $.Return.Type)}}{{Template "C.Type" $.Return.Type}} _return;{{end}}
  } {{$name}};
{{end}}
